// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by , version 
// ONNX IR version: 14
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

/* W0*/
static const float tensor_W0[1][1] = 
{
  {1.0000000000000000000f}
};
/* B0*/
static const float tensor_B0[1] = 
{0.0000000000000000000f};
/* W1*/
static const float tensor_W1[1][1] = 
{
  {1.0000000000000000000f}
};
/* B1*/
static const float tensor_B1[1] = 
{0.0000000000000000000f};
/* M0*/
static float tensor_M0[1][22029];
/* H0*/
static float tensor_H0[1][22029];
/* R0*/
static float tensor_R0[1][22029];
/* M1*/
static float tensor_M1[1][22029];

static inline void node_anonymous_MatMul_0( const float A[1][1], const float B[1], float Y[1][22029] )
{
	/* MatMul */
	for( uint32_t r=0; r<1; r++ )
		for( uint32_t c=0; c<22029; c++ ) {
			Y[r][c] = 0;
			for( uint32_t i=0; i<1; i++ )
				Y[r][c] += A[r][i] * B[i][c];
		}
}

static inline void node_anonymous_Add_1( const float tensor_M0[1][22029], const float tensor_B0[1], float tensor_H0[1][22029] )
{
	/* Add
	   Implemented with Elementwise_2 template.
	   Attributes (these are the union of attributes for all 2-element-wise
	               operands. So most likely these values are ignored by onnx2c).
	   shift_dir: NOT_GIVEN
	   fmod: 0
	 */
	for (unsigned i0=0; i0<1; i0++) {
	for (unsigned i1=0; i1<22029; i1++) {
		tensor_H0[i0][i1] = tensor_M0[0][i1]+tensor_B0[0];;
	}
	}
}

static inline void node_anonymous_Relu_2( const float tensor_H0[1][22029], float tensor_R0[1][22029] )
{
	/*Relu*/
	float *X = (float*)tensor_H0;
	float *Y = (float*)tensor_R0;
	for( uint32_t i=0; i<22029; i++ )
		Y[i] = X[i] > 0 ? X[i] : 0;

}

static inline void node_anonymous_MatMul_3( const float A[1][1], const float B[1][22029], float Y[1][22029] )
{
	/* MatMul */
	for( uint32_t r=0; r<1; r++ )
		for( uint32_t c=0; c<22029; c++ ) {
			Y[r][c] = 0;
			for( uint32_t i=0; i<1; i++ )
				Y[r][c] += A[r][i] * B[i][c];
		}
}

static inline void node_anonymous_Add_4( const float tensor_M1[1][22029], const float tensor_B1[1], float tensor_Y_0[1][22029] )
{
	/* Add
	   Implemented with Elementwise_2 template.
	   Attributes (these are the union of attributes for all 2-element-wise
	               operands. So most likely these values are ignored by onnx2c).
	   shift_dir: NOT_GIVEN
	   fmod: 0
	 */
	for (unsigned i0=0; i0<1; i0++) {
	for (unsigned i1=0; i1<22029; i1++) {
		tensor_Y_0[i0][i1] = tensor_M1[0][i1]+tensor_B1[0];;
	}
	}
}


void entry(const float tensor_X_0[1], float tensor_Y_0[1]) {
	node_anonymous_MatMul_0( tensor_W0, tensor_X_0, tensor_M0);
	node_anonymous_Add_1( tensor_M0, tensor_B0, tensor_H0);
	node_anonymous_Relu_2( tensor_H0, tensor_R0);
	node_anonymous_MatMul_3( tensor_W1, tensor_R0, tensor_M1);
	node_anonymous_Add_4( tensor_M1, tensor_B1, tensor_Y_0);
}

