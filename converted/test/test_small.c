// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by , version 
// ONNX IR version: 14
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

/* W0*/
static const float tensor_W0[2][1] = 
{
  {1.0000000000000000000f},
  {1.0000000000000000000f}
};
/* B0*/
static const float tensor_B0[2] = 
{1.5000000000000000000f, 1.5000000000000000000f};
/* W1*/
static const float tensor_W1[2][2] = 
{
  {2.0000000000000000000f, 2.0000000000000000000f},
  {2.0000000000000000000f, 2.0000000000000000000f}
};
/* B1*/
static const float tensor_B1[2] = 
{2.5000000000000000000f, 2.5000000000000000000f};
/* W2*/
static const float tensor_W2[1][2] = 
{
  {3.0000000000000000000f, 3.0000000000000000000f}
};
/* B2*/
static const float tensor_B2[1] = 
{3.5000000000000000000f};
/* M0*/
static float tensor_M0[2][1];
/* H0*/
static float tensor_H0[2][2];
/* R0*/
static float tensor_R0[2][2];
/* M1*/
static float tensor_M1[2][2];
/* H1*/
static float tensor_H1[2][2];
/* R1*/
static float tensor_R1[2][2];
/* M2*/
static float tensor_M2[1][2];

static inline void node_anonymous_MatMul_0( const float A[2][1], const float B[1], float Y[2][1] )
{
	/* MatMul */
	for( uint32_t r=0; r<2; r++ )
		for( uint32_t c=0; c<0; c++ ) {
			Y[r][c] = 0;
			for( uint32_t i=0; i<1; i++ )
				Y[r][c] += A[r][i] * B[i][c];
		}
}

static inline void node_anonymous_Add_1( const float tensor_M0[2][1], const float tensor_B0[2], float tensor_H0[2][2] )
{
	/* Add
	   Implemented with Elementwise_2 template.
	   Attributes (these are the union of attributes for all 2-element-wise
	               operands. So most likely these values are ignored by onnx2c).
	   shift_dir: NOT_GIVEN
	   fmod: 0
	 */
	for (unsigned i0=0; i0<2; i0++) {
	for (unsigned i1=0; i1<2; i1++) {
		tensor_H0[i0][i1] = tensor_M0[i0][0]+tensor_B0[i1];;
	}
	}
}

static inline void node_anonymous_Relu_2( const float tensor_H0[2][2], float tensor_R0[2][2] )
{
	/*Relu*/
	float *X = (float*)tensor_H0;
	float *Y = (float*)tensor_R0;
	for( uint32_t i=0; i<4; i++ )
		Y[i] = X[i] > 0 ? X[i] : 0;

}

static inline void node_anonymous_MatMul_3( const float A[2][2], const float B[2][2], float Y[2][2] )
{
	/* MatMul */
	for( uint32_t r=0; r<2; r++ )
		for( uint32_t c=0; c<2; c++ ) {
			Y[r][c] = 0;
			for( uint32_t i=0; i<2; i++ )
				Y[r][c] += A[r][i] * B[i][c];
		}
}

static inline void node_anonymous_Add_4( const float tensor_M1[2][2], const float tensor_B1[2], float tensor_H1[2][2] )
{
	/* Add
	   Implemented with Elementwise_2 template.
	   Attributes (these are the union of attributes for all 2-element-wise
	               operands. So most likely these values are ignored by onnx2c).
	   shift_dir: NOT_GIVEN
	   fmod: 0
	 */
	for (unsigned i0=0; i0<2; i0++) {
	for (unsigned i1=0; i1<2; i1++) {
		tensor_H1[i0][i1] = tensor_M1[i0][i1]+tensor_B1[i1];;
	}
	}
}

static inline void node_anonymous_Relu_5( const float tensor_H1[2][2], float tensor_R1[2][2] )
{
	/*Relu*/
	float *X = (float*)tensor_H1;
	float *Y = (float*)tensor_R1;
	for( uint32_t i=0; i<4; i++ )
		Y[i] = X[i] > 0 ? X[i] : 0;

}

static inline void node_anonymous_MatMul_6( const float A[1][2], const float B[2][2], float Y[1][2] )
{
	/* MatMul */
	for( uint32_t r=0; r<1; r++ )
		for( uint32_t c=0; c<2; c++ ) {
			Y[r][c] = 0;
			for( uint32_t i=0; i<2; i++ )
				Y[r][c] += A[r][i] * B[i][c];
		}
}

static inline void node_anonymous_Add_7( const float tensor_M2[1][2], const float tensor_B2[1], float tensor_Y_0[1][2] )
{
	/* Add
	   Implemented with Elementwise_2 template.
	   Attributes (these are the union of attributes for all 2-element-wise
	               operands. So most likely these values are ignored by onnx2c).
	   shift_dir: NOT_GIVEN
	   fmod: 0
	 */
	for (unsigned i0=0; i0<1; i0++) {
	for (unsigned i1=0; i1<2; i1++) {
		tensor_Y_0[i0][i1] = tensor_M2[0][i1]+tensor_B2[0];;
	}
	}
}


void entry(const float tensor_X_0[1], float tensor_Y_0[1]) {
	node_anonymous_MatMul_0( tensor_W0, tensor_X_0, tensor_M0);
	node_anonymous_Add_1( tensor_M0, tensor_B0, tensor_H0);
	node_anonymous_Relu_2( tensor_H0, tensor_R0);
	node_anonymous_MatMul_3( tensor_W1, tensor_R0, tensor_M1);
	node_anonymous_Add_4( tensor_M1, tensor_B1, tensor_H1);
	node_anonymous_Relu_5( tensor_H1, tensor_R1);
	node_anonymous_MatMul_6( tensor_W2, tensor_R1, tensor_M2);
	node_anonymous_Add_7( tensor_M2, tensor_B2, tensor_Y_0);
}

